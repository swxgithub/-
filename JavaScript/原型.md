1.函数的prototype属性

*每个函数都有一个prototype属性，默认指向一个Object空对象（即称为：原型对象）。

​		空对象是指没有我们自己添加的属性的对象。

*原型对象中有一个属性constructor（构造函数），指向函数对象。

​		构造函数与函数对象相互引用。

2.给原型对象添加属性（一般都是方法）===> 实例对象可以访问

*作用：函数的所有实例对象自动拥有原型中的属性。



补充快捷键-->重命名：alt+shift+r



显示原型和隐式原型

1.每个函数function都有一个prototype，即显示原型。

2.每个实例对象都有一个__proto__，即隐式对象。

3.对象的隐式原型的值为其对应构造函数的显示原型的值（地址值），共同指向原型对象。

4.内存结构（如图）

![image-20210226164143338](C:\Users\Fudan_CSer\AppData\Roaming\Typora\typora-user-images\image-20210226164143338.png)

5.总结：

*函数的prototype属性：在定义函数时自动添加的，默认值是一个空Object对象。

*对象的__proto__属性：创建对时自动添加的，默认值为构造函数的prototype属性值。

*程序员能直接操作显示原型，但不能直接操作隐式原型（ES6之前）。



原型链

![image-20210228144719090](C:\Users\Fudan_CSer\AppData\Roaming\Typora\typora-user-images\image-20210228144719090.png)

如图为原型链图解，Object的原型对象是原型链的终点，proto属性的值为null。

访问一个对象的属性时，

​	*先在自身属性中查找，找到返回

​	*如果没有，再沿着proto这条链向上查找，找到返回

​	*如果最终没有找到，返回undefined

别名：隐式原型链

作用：查找对象的属性（方法）



补充：所有函数都是Function的实例。



原型链的属性问题：

1.读取对象的属性值时，会自动到原型链中查找

2.设置对象的属性值时，不会查找原型链，如果当前对象中没有此属性，直接添加此属性并设置其值

3.方法一般定义在原型中，属性一般通过构造函数定义在对象本身上



instanceof

*表达式：A instanceof B

*如果B函数的显示原型对象在A对象的原型链上，返回true，否则返回false

Function是通过new自己产生的实例

 